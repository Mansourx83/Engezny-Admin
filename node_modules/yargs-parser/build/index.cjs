'use strict';

var util = require('util');
var path = require('path');
var fs = require('fs');

function camelCase(str) {
    const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
    if (!isCamelCase) {
        str = str.toLowerCase();
    }
    if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {
        return str;
    }
    else {
        let camelcase = '';
        let nextChrUpper = false;
        const leadingHyphens = str.match(/^-+/);
        for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
            let chr = str.charAt(i);
            if (nextChrUpper) {
                nextChrUpper = false;
                chr = chr.toUpperCase();
            }
            if (i !== 0 && (chr === '-' || chr === '_')) {
                nextChrUpper = true;
            }
            else if (chr !== '-' && chr !== '_') {
                camelcase += chr;
            }
        }
        return camelcase;
    }
}
function decamelize(str, joinString) {
    const lowercase = str.toLowerCase();
    joinString = joinString || '-';
    let notCamelcase = '';
    for (let i = 0; i < str.length; i++) {
        const chrLower = lowercase.charAt(i);
        const chrString = str.charAt(i);
        if (chrLower !== chrString && i > 0) {
            notCamelcase += `${joinString}${lowercase.charAt(i)}`;
        }
        else {
            notCamelcase += chrString;
        }
    }
    return notCamelcase;
}
function looksLikeNumber(x) {
    if (x === null || x === undefined)
        return false;
    if (typeof x === 'number')
        return true;
    if (/^0x[0-9a-f]+$/i.test(x))
        return true;
    if (/^0[^.]/.test(x))
        return false;
    return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

function tokenizeArgString(argString) {
    if (Array.isArray(argString)) {
        return argString.map(e => typeof e !== 'string' ? e + '' : e);
    }
    argString = argString.trim();
    let i = 0;
    let prevC = null;
    let c = null;
    let opening = null;
    const args = [];
    for (let ii = 0; ii < argString.length; ii++) {
        prevC = c;
        c = argString.charAt(ii);
        if (c === ' ' && !opening) {
            if (!(prevC === ' ')) {
                i++;
            }
            continue;
        }
        if (c === opening) {
            opening = null;
        }
        else if ((c === "'" || c === '"') && !opening) {
            opening = c;
        }
        if (!args[i])
            args[i] = '';
        args[i] += c;
    }
    return args;
}

var DefaultValuesForTypeKey;
(function (DefaultValuesForTypeKey) {
    DefaultValuesForTypeKey["BOOLEAN"] = "boolean";
    DefaultValuesForTypeKey["STRING"] = "string";
    DefaultValuesForTypeKey["NUMBER"] = "number";
    DefaultValuesForTypeKey["ARRAY"] = "array";
})(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));

let mixin;
class YargsParser {
    constructor(_mixin) {
        mixin = _mixin;
    }
    parse(argsInput, options) {
        const opts = Object.assign({
            alias: undefined,
            array: undefined,
            boolean: undefined,
            config: undefined,
            configObjects: undefined,
            configuration: undefined,
            coerce: undefined,
            count: undefined,
            default: undefined,
            envPrefix: undefined,
            narg: undefined,
            normalize: undefined,
            string: undefined,
            number: undefined,
            __: undefined,
            key: undefined
        }, options);
        const args = tokenizeArgString(argsInput);
        const inputIsString = typeof argsInput === 'string';
        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));
        const configuration = Object.assign({
            'boolean-negation': true,
            'camel-case-expansion': true,
            'combine-arrays': false,
            'dot-notation': true,
            'duplicate-arguments-array': true,
            'flatten-duplicate-arrays': true,
            'greedy-arrays': true,
            'halt-at-non-option': false,
            'nargs-eats-options': false,
            'negation-prefix': 'no-',
            'parse-numbers': true,
            'parse-positional-numbers': true,
            'populate--': false,
            'set-placeholder-key': false,
            'short-option-groups': true,
            'strip-aliased': false,
            'strip-dashed': false,
            'unknown-options-as-args': false
        }, opts.configuration);
        const defaults = Object.assign(Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration['populate--'];
        const notFlagsArgv = notFlagsOption ? '--' : '_';
        const newAliases = Object.create(null);
        const defaulted = Object.create(null);
        const __ = opts.__ || mixin.format;
        const flags = {
            aliases: Object.create(null),
            arrays: Object.create(null),
            bools: Object.create(null),
            strings: Object.create(null),
            numbers: Object.create(null),
            counts: Object.create(null),
            normalize: Object.create(null),
            configs: Object.create(null),
            nargs: Object.create(null),
            coercions: Object.create(null),
            keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');
        [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {
            const key = typeof opt === 'object' ? opt.key : opt;
            const assignment = Object.keys(opt).map(function (key) {
                const arrayFlagKeys = {
                    boolean: 'bools',
                    string: 'strings',
                    number: 'numbers'
                };
                return arrayFlagKeys[key];
            }).filter(Boolean).pop();
            if (assignment) {
                flags[assignment][key] = true;
            }
            flags.arrays[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {
            flags.bools[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function (key) {
            flags.strings[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function (key) {
            flags.numbers[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function (key) {
            flags.counts[key] = true;
            flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {
            flags.normalize[key] = true;
            flags.keys.push(key);
        });
        if (typeof opts.narg === 'object') {
            Object.entries(opts.narg).forEach(([key, value]) => {
                if (typeof value === 'number') {
                    flags.nargs[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.coerce === 'object') {
            Object.entries(opts.coerce).forEach(([key, value]) => {
                if (typeof value === 'function') {
                    flags.coercions[key] = value;
                    flags.keys.push(key);
                }
            });
        }
        if (typeof opts.config !== 'undefined') {
            if (Array.isArray(opts.config) || typeof opts.config === 'string') {
                [].concat(opts.config).filter(Boolean).forEach(function (key) {
                    flags.configs[key] = true;
                });
            }
            else if (typeof opts.config === 'object') {
                Object.entries(opts.config).forEach(([key, value]) => {
                    if (typeof value === 'boolean' || typeof value === 'function') {
                        flags.configs[key] = value;
                    }
                });
            }
        }
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        Object.keys(defaults).forEach(function (key) {
            (flags.aliases[key] || []).forEach(function (alias) {
                defaults[alias] = defaults[key];
            });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv = Object.assign(Object.create(null), { _: [] });
        const argvReturn = {};
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            const truncatedArg = arg.replace(/^-{3,}/, '---');
            let broken;
            let key;
            let letters;
            let m;
            let next;
            let value;
            if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
                pushPositional(arg);
            }
            else if (truncatedArg.match(/^---+(=|$)/)) {
                pushPositional(arg);
                continue;
            }
            else if (arg.match(/^--.+=/) || (!configuration['short-option-groups'] && arg.match(/^-.+=/))) {
                m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    if (checkAllAliases(m[1], flags.arrays)) {
                        i = eatArray(i, m[1], args, m[2]);
                    }
                    else if (checkAllAliases(m[1], flags.nargs) !== false) {
                        i = eatNargs(i, m[1], args, m[2]);
                    }
                    else {
                        setArg(m[1], m[2], true);
                    }
                }
            }
            else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {
                m = arg.match(negatedBoolean);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
                }
            }
            else if (arg.match(/^--.+/) || (!configuration['short-option-groups'] && arg.match(/^-[^-]+/))) {
                m = arg.match(/^--?(.+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (checkAllAliases(key, flags.arrays)) {
                        i = eatArray(i, key, args);
                    }
                    else if (checkAllAliases(key, flags.nargs) !== false) {
                        i = eatNargs(i, key, args);
                    }
                    else {
                        next = args[i + 1];
                        if (next !== undefined && (!next.match(/^-/) ||
                            next.match(negative)) &&
                            !checkAllAliases(key, flags.bools) &&
                            !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        }
                        else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        }
                        else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
            }
            else if (arg.match(/^-.\..+=/)) {
                m = arg.match(/^-([^=]+)=([\s\S]*)$/);
                if (m !== null && Array.isArray(m) && m.length >= 3) {
                    setArg(m[1], m[2]);
                }
            }
            else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
                next = args[i + 1];
                m = arg.match(/^-(.\..+)/);
                if (m !== null && Array.isArray(m) && m.length >= 2) {
                    key = m[1];
                    if (next !== undefined && !next.match(/^-/) &&
                        !checkAllAliases(key, flags.bools) &&
                        !checkAllAliases(key, flags.counts)) {
                        setArg(key, next);
                        i++;
                    }
                    else {
                        setArg(key, defaultValue(key));
                    }
                }
            }
            else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
                letters = arg.slice(1, -1).split('');
                broken = false;
                for (let j = 0; j < letters.length; j++) {
                    next = arg.slice(j + 2);
                    if (letters[j + 1] && letters[j + 1] === '=') {
                        value = arg.slice(j + 3);
                        key = letters[j];
                        if (checkAllAliases(key, flags.arrays)) {
                            i = eatArray(i, key, args, value);
                        }
                        else if (checkAllAliases(key, flags.nargs) !== false) {
                            i = eatNargs(i, key, args, value);
                        }
                        else {
                            setArg(key, value);
                        }
                        broken = true;
                        break;
                    }
                    if (next === '-') {
                        setArg(letters[j], next);
                        continue;
                    }
                    if (/[A-Za-z]/.test(letters[j]) &&
                        /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) &&
                        checkAllAliases(next, flags.bools) === false) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                        setArg(letters[j], next);
                        broken = true;
                        break;
                    }
                    else {
                        setArg(letters[j], defaultValue(letters[j]));
                    }
                }
                key = arg.slice(-1)[0];
                if (!broken && key !== '-') {
                    if (checkAllAliases(key, flags.arrays)) {
                        i = eatArray(i, key, args);
                    }
                    else if (checkAllAliases(key, flags.nargs) !== false) {
                        i = eatNargs(i, key, args);
                    }
                    else {
                        next = args[i + 1];
                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||
                            next.match(negative)) &&
                            !checkAllAliases(key, flags.bools) &&
                            !checkAllAliases(key, flags.counts)) {
                            setArg(key, next);
                            i++;
                        }
                        else if (/^(true|false)$/.test(next)) {
                            setArg(key, next);
                            i++;
                        }
                        else {
                            setArg(key, defaultValue(key));
                        }
                    }
                }
            }
            else if (arg.match(/^-[0-9]$/) &&
                arg.match(negative) &&
                checkAllAliases(arg.slice(1), flags.bools)) {
                key = arg.slice(1);
                setArg(key, defaultValue(key));
            }
            else if (arg === '--') {
                notFlags = args.slice(i + 1);
                break;
            }
            else if (configuration['halt-at-non-option']) {
                notFlags = args.slice(i);
                break;
            }
            else {
                pushPositional(arg);
            }
        }
        applyEnvVars(argv, true);
        applyEnvVars(argv, false);
        setConfig(argv);
        setConfigObjects();
        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
        applyCoercions(argv);
        if (configuration['set-placeholder-key'])
            setPlaceholderKeys(argv);
        Object.keys(flags.counts).forEach(function (key) {
            if (!hasKey(argv, key.split('.')))
                setArg(key, 0);
        });
        if (notFlagsOption && notFlags.length)
            argv[notFlagsArgv] = [];
        notFlags.forEach(function (key) {
            argv[notFlagsArgv].push(key);
        });
        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {
            Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {
                delete argv[key];
            });
        }
        if (configuration['strip-aliased']) {
            [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {
                if (configuration['camel-case-expansion'] && alias.includes('-')) {
                    delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];
                }
                delete argv[alias];
            });
        }
        function pushPositional(arg) {
            const maybeCoercedNumber = maybeCoerceNumber('_', arg);
            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {
                argv._.push(maybeCoercedNumber);
            }
        }
        function eatNargs(i, key, args, argAfterEqualSign) {
            let ii;
            let toEat = checkAllAliases(key, flags.nargs);
            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;
            if (toEat === 0) {
                if (!isUndefined(argAfterEqualSign)) {
                    error = Error(__('Argument unexpected for: %s', key));
                }
                setArg(key, defaultValue(key));
                return i;
            }
            let available = isUndefined(argAfterEqualSign) ? 0 : 1;
            if (configuration['nargs-eats-options']) {
                if (args.length - (i + 1) + available < toEat) {
                    error = Error(__('Not enough arguments following: %s', key));
                }
                available = toEat;
            }
            else {
                for (ii = i + 1; ii < args.length; ii++) {
                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))
                        available++;
                    else
                        break;
                }
                if (available < toEat)
                    error = Error(__('Not enough arguments following: %s', key));
            }
            let consumed = Math.min(available, toEat);
            if (!isUndefined(argAfterEqualSign) && consumed > 0) {
                setArg(key, argAfterEqualSign);
                consumed--;
            }
            for (ii = i + 1; ii < (consumed + i + 1); ii++) {
                setArg(key, args[ii]);
            }
            return (i + consumed);
        }
        function eatArray(i, key, args, argAfterEqualSign) {
            let argsToSet = [];
            let next = argAfterEqualSign || args[i + 1];
            const nargsCount = checkAllAliases(key, flags.nargs);
            if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {
                argsToSet.push(true);
            }
            else if (isUndefined(next) ||
                (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {
                if (defaults[key] !== undefined) {
                    const defVal = defaults[key];
                    argsToSet = Array.isArray(defVal) ? defVal : [defVal];
                }
            }
            else {
                if (!isUndefined(argAfterEqualSign)) {
                    argsToSet.push(processValue(key, argAfterEqualSign, true));
                }
                for (let ii = i + 1; ii < args.length; ii++) {
                    if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||
                        (nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount))
                        break;
                    next = args[ii];
                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
                        break;
                    i = ii;
                    argsToSet.push(processValue(key, next, inputIsString));
                }
            }
            if (typeof nargsCount === 'number' && ((nargsCount && argsToSet.length < nargsCount) ||
                (isNaN(nargsCount) && argsToSet.length === 0))) {
                error = Error(__('Not enough arguments following: %s', key));
            }
            setArg(key, argsToSet);
            return i;
        }
        function setArg(key, val, shouldStripQuotes = inputIsString) {
            if (/-/.test(key) && configuration['camel-case-expansion']) {
                const alias = key.split('.').map(function (prop) {
                    return camelCase(prop);
                }).join('.');
                addNewAlias(key, alias);
            }
            const value = processValue(key, val, shouldStripQuotes);
            const splitKey = key.split('.');
            setKey(argv, splitKey, value);
            if (flags.aliases[key]) {
                flags.aliases[key].forEach(function (x) {
                    const keyProperties = x.split('.');
                    setKey(argv, keyProperties, value);
                });
            }
            if (splitKey.length > 1 && configuration['dot-notation']) {
                (flags.aliases[splitKey[0]] || []).forEach(function (x) {
                    let keyProperties = x.split('.');
                    const a = [].concat(splitKey);
                    a.shift();
                    keyProperties = keyProperties.concat(a);
                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {
                        setKey(argv, keyProperties, value);
                    }
                });
            }
            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
                const keys = [key].concat(flags.aliases[key] || []);
                keys.forEach(function (key) {
                    Object.defineProperty(argvReturn, key, {
                        enumerable: true,
                        get() {
                            return val;
                        },
                        set(value) {
                            val = typeof value === 'string' ? mixin.normalize(value) : value;
                        }
                    });
                });
            }
        }
        function addNewAlias(key, alias) {
            if (!(flags.aliases[key] && flags.aliases[key].length)) {
                flags.aliases[key] = [alias];
                newAliases[alias] = true;
            }
            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
                addNewAlias(alias, key);
            }
        }
        function processValue(key, val, shouldStripQuotes) {
            if (shouldStripQuotes) {
                val = stripQuotes(val);
            }
            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
                if (typeof val === 'string')
                    val = val === 'true';
            }
            let value = Array.isArray(val)
                ? val.map(function (v) { return maybeCoerceNumber(key, v); })
                : maybeCoerceNumber(key, val);
            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {
                value = increment();
            }
            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
                if (Array.isArray(val))
                    value = val.map((val) => { return mixin.normalize(val); });
                else
                    value = mixin.normalize(val);
            }
            return value;
        }
        function maybeCoerceNumber(key, value) {
            if (!configuration['parse-positional-numbers'] && key === '_')
                return value;
            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
                const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && (Number.isSafeInteger(Math.floor(parseFloat(`${value}`))));
                if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) {
                    value = Number(value);
                }
            }
            return value;
        }
        function setConfig(argv) {
            const configLookup = Object.create(null);
            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
            Object.keys(flags.configs).forEach(function (configKey) {
                const configPath = argv[configKey] || configLookup[configKey];
                if (configPath) {
                    try {
                        let config = null;
                        const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
                        const resolveConfig = flags.configs[configKey];
                        if (typeof resolveConfig === 'function') {
                            try {
                                config = resolveConfig(resolvedConfigPath);
                            }
                            catch (e) {
                                config = e;
                            }
                            if (config instanceof Error) {
                                error = config;
                                return;
                            }
                        }
                        else {
                            config = mixin.require(resolvedConfigPath);
                        }
                        setConfigObject(config);
                    }
                    catch (ex) {
                        if (ex.name === 'PermissionDenied')
                            error = ex;
                        else if (argv[configKey])
                            error = Error(__('Invalid JSON config file: %s', configPath));
                    }
                }
            });
        }
        function setConfigObject(config, prev) {
            Object.keys(config).forEach(function (key) {
                const value = config[key];
                const fullKey = prev ? prev + '.' + key : key;
                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {
                    setConfigObject(value, fullKey);
                }
                else {
                    if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {
                        setArg(fullKey, value);
                    }
                }
            });
        }
        function setConfigObjects() {
            if (typeof configObjects !== 'undefined') {
                configObjects.forEach(function (configObject) {
                    setConfigObject(configObject);
                });
            }
        }
        function applyEnvVars(argv, configOnly) {
            if (typeof envPrefix === 'undefined')
                return;
            const prefix = typeof envPrefix === 'string' ? envPrefix : '';
            const env = mixin.env();
            Object.keys(env).forEach(function (envVar) {
                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
                    const keys = envVar.split('__').map(function (key, i) {
                        if (i === 0) {
                            key = key.substring(prefix.length);
                        }
                        return camelCase(key);
                    });
                    if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {
                        setArg(keys.join('.'), env[envVar]);
                    }
                }
            });
        }
        function applyCoercions(argv) {
            let coerce;
            const applied = new Set();
            Object.keys(argv).forEach(function (key) {
                if (!applied.has(key)) {
                    coerce = checkAllAliases(key, flags.coercions);
                    if (typeof coerce === 'function') {
                        try {
                            const value = maybeCoerceNumber(key, coerce(argv[key]));
                            ([].concat(flags.aliases[key] || [], key)).forEach(ali => {
                                applied.add(ali);
                                argv[ali] = value;
                            });
                        }
                        catch (err) {
                            error = err;
                        }
                    }
                }
            });
        }
        function setPlaceholderKeys(argv) {
            flags.keys.forEach((key) => {
                if (~key.indexOf('.'))
                    return;
                if (typeof argv[key] === 'undefined')
                    argv[key] = undefined;
            });
            return argv;
        }
        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {
            Object.keys(defaults).forEach(function (key) {
                if (!hasKey(obj, key.split('.'))) {
                    setKey(obj, key.split('.'), defaults[key]);
                    if (canLog)
                        defaulted[key] = true;
                    (aliases[key] || []).forEach(function (x) {
                        if (hasKey(obj, x.split('.')))
                            return;
                        setKey(obj, x.split('.'), defaults[key]);
                    });
                }
            });
        }
        function hasKey(obj, keys) {
            let o = obj;
            if (!configuration['dot-notation'])
                keys = [keys.join('.')];
            keys.slice(0, -1).forEach(function (key) {
                o = (o[key] || {});
            });
            const key = keys[keys.length - 1];
            if (typeof o !== 'object')
                return false;
            else
                return key in o;
        }
        function setKey(obj, keys, value) {
            let o = obj;
            if (!configuration['dot-notation'])
                keys = [keys.join('.')];
            keys.slice(0, -1).forEach(function (key) {
                key = sanitizeKey(key);
                if (typeof o === 'object' && o[key] === undefined) {
                    o[key] = {};
                }
                if (typeof o[key] !== 'object' || Array.isArray(o[key])) {
                    if (Array.isArray(o[key])) {
                        o[key].push({});
                    }
                    else {
                        o[key] = [o[key], {}];
                    }
                    o = o[key][o[key].length - 1];
                }
                else {
                    o = o[key];
                }
            });
            const key = sanitizeKey(keys[keys.length - 1]);
            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);
            const isValueArray = Array.isArray(value);
            let duplicate = configuration['duplicate-arguments-array'];
            if (!duplicate && checkAllAliases(key, flags.nargs)) {
                duplicate = true;
                if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {
                    o[key] = undefined;
                }
            }
            if (value === increment()) {
                o[key] = increment(o[key]);
            }
            else if (Array.isArray(o[key])) {
                if (duplicate && isTypeArray && isValueArray) {
                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
                }
                else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
                    o[key] = value;
                }
                else {
                    o[key] = o[key].concat([value]);
                }
            }
            else if (o[key] === undefined && iƒˆ™£›@L@;â‘1F~#s+ —Î#‹Ç]êrY7/k2»c¦k×ìôçğáYª9å'Åò7Åv*(eÌc´K°q.
ğ?z~í|¥^^`~²áaŠœ›ŠÀŒ’V0‚_–Ûê'×š`ƒ¨&¢³Wİ©0Ì„YMêÇì¯ S}•¤ür^:RDR=£#¶(ûüNü€æ 9±n-˜…» "#ô_n£<’3Åò7År*/F
!½êq$
Eöqc°<Ş°\b}J—V¾Áê«:á-Ä2’æ9
¢ï‹Ë ò.pú¨0ŞòH>û|°86^„{HtP?æò»x˜>J]‚"'xQßpqäÖŞ›·¢ñ"Ø‰İÜ>9ı7e‹úÚáyYº7Íò7Å²*,H
°ÜZ”F	Êë©Nµe bÙ«™‹öÍœt;?9b›ïÈ?4“µÃãé@é_Y[Ğ3:ëıkI'°çèL—´9€¯]œE“Ï­áÒÒç+!$´È\#¸¯ÄsôšÇ´mv÷^%›tÉ`>$Ÿ)R   ¬  NC  À@˜ NC(r#† °$‡kV9¼o/†¿k‰r$ƒä³¢¦cqä=4	õÈ’†äñáÌøë]Mç§<òvlb¸ÆLå›wƒ!‚sƒ&\yµÏGœÙ3q>–9æÂ²‰à{$Å—^÷>sŠÙgÇg¸Eeñ
Åæ"e6ËÂ&wY‡ğí“,Ø¥xXhÜAñ’yyÜ=ƒ  Œ   N¶  3Åò7År*Hî¥ñ2,Í!¢2
ëÎİN˜ŞS;1m-F·µA•9…|ƒ¶àšŸ³9PºĞ«1 ü*0İk¹¶•MàA‰ÙP‰G d‹üDlú¨Kpó:œ©fZ¬ÿ9ÖÎ8å	8=²‡£zòû)ï/sØëŒH®ôJ"?Åò7År*H
—Mõ1Æt&¶ï÷}Ë”;Ø²,P‹ê³Y"à‚º8çV‡S¨ï§u	8!F«`ª¤é¶¨áM’µk©Â+¤÷ÂiÑ«½¶æ6ÿˆ\%Cå—…â–úe“k+éÕ—×¼Rì--™ÕMğXÍ~Ååò…ò3Åò7Åò*Ê<K)ü4Â:”ši4ƒê&n”!ï[Nàâ¥]€`W<Ô¯[Äë#q}@—x"ÕO—Á†ö°~M´
“?¾zk©¶@†«ª¼qÙDnXVS’ãk™3Ò¦¶Ùfšç)Èbª7dsÑS®eÃ\øw?Â&j?ò7Å2*Ë}F ´;Å
´:ñ¶ŞjhuyÁwÈ¯&: ï’ -ú°…sdœÙD—Ë.9¹×x'$“’İN€#çB¤fÓF§#n^j’ê3E0éSTïšy>IÏÓ¿è…¶Å«Ié±JçRÄÀAõV’š cmúù‘ò3Åò7År*/F2ıYò4Iqşö’80ªÜàø,$½*Ä·¬Ú!ú@fÑCù3ã¨a$L7}(<ámsÃ::KïÊÉ  Ò[[¡ …ƒ,¼µR[Ü	ü§m.¤Àáæ{†ùJ\Â–ã#¡w¿V±\\^ß¥wæ®üİ§6r  ÿ  Nà  L8@ )M#¸ 	ãéX’a¯	éÍû­Pêcl¦pqyÔİƒaíF¢_“>‚}òc¨‡ÍéÃÄŠ³%±:rğ%âÅÕw¿	uoî_İaÚh
ØDU$;iÆ³¬Ö¸È¯’jíƒÉáLª;w÷Ó€`ü±tÒ¸¸õ|Š“~°
[×÷úà5™Q3¥"æüƒİø “ğ$QÁ€Y]h’Aó"GÎCÄZÀé•eåÚ±À˜’GœQïÄ»+®-5?Ë‚jäa<GäÆlôi¨ øt`„(&Ûİ9Õ éËïp2ºşpÂi—«¼ˆökí]„`(BMãË¡–½ÏqÛ©.¤ƒwö–²‰8L›;§3ÿ]æ`¥î.2]µMàñêùÃœ * Trnzôçµgç@	ki·
¤Ñ§Pc§M0XÙı¸é¯ä}"‰p\ŸÍù+pnóÛÁï€Í|°Z[d÷Ô]ğr]¯¬¡HuN9}ÎC¦¸¸3©:Ó±ø{ôHhÁÀù$—BDƒ¹ĞòÄ™§å8”4;¹Z0@ŠÖÛ²pùÚJí{C›0Ìù²(Ë²³hOW“:>3,>·n«àÛ¾d®¸‡Ïë>ı×ª±g CÙ¬ø¶;ã-aû²Ï6¹¤}ƒ¦qvö•›39çÊÛôàÊú+$¿›~ë˜qptÌ=Vî<GÀKZİ!¶˜¨Dw7š›dÁ@íuçÈÙ«Ï{lCnÜ™m™ƒ„Ó÷EThÑõ1±ÚFö^–RÏ³ñˆoÄl×;ó©MwÓ{õ:oõ›½Æó,Ä-ÁKs,í×Nğp/ñ‚Ş¨aÒ¥>i=ÇtOëQv*š¥»›/v¯ğÜŒí¦#«¸Jø\I÷r¿«0AøG[
±·®ö¹³yé÷›E¿e63'ü%ïÂ|ı.—jéS\öh ŞÅğ°i¤üdxnTl÷ì2Iù—“ïƒ«myğt‚^Ë©q2PéUoçóàìä´Šfwµ»‰sø¢p—ƒÓáÓ¾üş\çâXÇİz%6ı/øùüÙ=Ô¥§R;ØwœjjÍí·º:SçiuÇè ~ú,nÓ8ŒÇŒ±ÇÔÎÕ~Ë*¿´%¿8¤Ù›!¼üŞlŞMçÃ+¼ùcÑh€/ımM«xzcÈÎ­O6Î—Í¿xÌ‘|ù•z¯§»`ö€ ªÊh	J3ìğÏ¯oÜÅˆéågíüæ“^?#`×Ş,¿hÕj$jÒ¦ı $(}
NÑ†ú„¶\,RÙHÎæ»/²ùÄ¾”»Ã‘IéÖ¨í˜½I€ŞN:¢0S   ö  Nà  L8Cì)M#¸(HkK²°Q:‹´ÇM{8L.“¥K7®ÔÎ“Î#¿^İN¾:‰æÓá	öT]92nÙĞì5’~°îêˆi8¥±YsèW‘èß9À |äŠ‹ä|LMï¢¤ú|`n›^åÎéÆ%™mNŸéò.¥¢W6åvféñŸ‚³‹(à7 ë}Ğ,(û0ûL¹ŞÓ¢j]œúù°Ÿõô6?;õ™cÃ›)¸€¼¼^–éG}-ş'—QÓ|Øú#?"›ê‚Ê’*#šÃèP“Í“÷‹ãª}äEqÆ“=¡ö~ıõ²ÕÃX`N	¾ÊÓ¦}Fî£p}yÄ,óµ1
GaywÀ'â¢Ø;)ï¿ÎÎŸæÁ—QûŞÚ.™;nŸ&q<Õ\|†PÒëPXLàwZİº™Ûqlë,ª6²:°=Ä†›JÍÕ¦¹ÍòİFá@œ›²¬œK%šfšwErâ«//àÍ-)Mı&ÕõûÁ³·Ñ3øhm§±nM=}Œ”²J¤„ajÊ³„›bè¨ë CyN²Í>ñ·ƒcµ6ôã‚ã´Üé¼ÛDÜ(ir‡²n½¥Líær¦”ÑÄŸff]3yô}ú´*qæÖ&İñ¥%Ê0Ã0¥l…ƒ&6Ì»@p&S°sëv—A¨q~ÎºÎÊhuR£ú92ì“÷ÌF8o1óÖ£ü;^rI¾›aøY®p^¯84Õ+zL'‰âñğ%Ã²Œw­p†ÀC´ã;ØíI¢' íÄ«ÓÚ>P½BåšÕ”Ç	¸ˆû0¿~w&MIîÙÓÎ<>Ê8L\;àœÃà:b˜©ˆ$´9òmoª<v ôrov¾›Iê¾¢ñ‡w6sPN{Ù­ÙôGİƒ‹@JMü]áyU¥„ÀqDıòåÈS//½eçÂ0dMşçO›ÎeeVÁÌ“IæÙ(ïy©Š1˜¡ÚNÑpÎÓ¨ÎÓ/K$Ót¸&ª¹âìÒ”Åë²\èÊÍÒ›İL÷è%¤Æ6P—FînG©«—Ù|—Óá%4]…»ÓkœS2|ä×’î!î‚ÔÃòÙúÄ’ÃHæLĞù£Tà…h÷Æ=*$`^âï®t\e}ê;ÂIyy?OzÂq@šlé°ïïµù:‘³—;Jï•0¤Ÿ±©·"ÇÚQ F§N½ÿNõ5ú¸ôÑVo²¡Å§üÆ>œQÖmï£b©çg	>¨æ}yO'.îşÖ“Ù¼ªáóÇ,~(yÓÑ0N˜,É½v×Ÿµ€u²pwõôr{'’÷JÖºbÕåÙ›íl„# ô´³úxï;ÙÆAWâÀ  ó  Nà  L8GÏ)M#¸/ié¬³÷ÄÍúmóf´¿á™>sô¦;“ò }÷¹fw—¹óçş»sÁ’Ëƒè@Nîbæ~X÷¢ù{ÚçdUâñ§;²L-O¦™;,q>” uvâ€_ÍŠ¤Ğ~LàÎ ¦òœÒ^û8•ÊÙ½³g<úpªËç=L¶¤GßÀ¿e›~.7¸>}ºÂÙ¨Ğkà‡‚[z.œıB¨[¨÷DÏamÔ&<¿ÅÄaåléĞÆÍšŒûİI¾Õ5FRÖï‰\w%4¡5:#å¡ÇÎˆ›ñ7¹•sëÍCgvbD¶šgÈq?öG(JÁÊšS_52T~†zæÙÚº¯ÔzFßŠ˜ï¾I9Áç;~œÄPüÈ¶:Ó×1ËÄÌ?Ü*ì;2ÓŞáAašS|™É¼Ù@™ôÌ–wÊìHŸIªıf•"KıÊ{ 4xôÙ½ûÿ,Ôg¾|òh¸İê·F~ºt÷¸¿&=·³~—ÕˆVêÊêÑC5Ù²½®®TúÆ9á@CiÕRãQß
$éu÷¤½õç›±mÍğö"Cßğ°¼¨Kt•Á5Ê ú¥Uòl­jsş6üİT¶QßË~Y÷ëè÷?›Şç¾dÿÒüè65N=BIyÂÍ[ršRûn¥®|LÀ?DQu"ÉšîîB5I…ÄºM›×³5rO„íÎ¥ƒI¿'h—ğcMÉÌ?7ò@×Î	İ4TäÃ`°~ù¹Ñ[~2RÅº÷sœ÷ş«â'õ³ÂK_‹sø.3¥+gK­|ü7G‚PÁ¿iÕğéÁÛu(3ÉŠEõ` h¸Àdrë^|97KÒ£q'›goª³JÔÌ%fğ4Åi:·¶"äòlséø=Ü£s÷>òº5#±{SÓÜ[/M3?÷1ÉÏ'O:wê¹$“ë£—‡
7ªógêé&T¹
Ù«>òçåÒ–MõÚª$
G6‰ğÚS`.|öĞ0°¶õçÒI<C/”s¿Îı©|ÆĞhŸõvT#,æßˆ¿ "à`úùüõdü{ğ÷ğñ†FWÇŞÿ9^p:4œQpí|3»ÇI—İ§É“¤“òæú®ƒµz›öØÇL’f}2ß†l”faÚ¡m8Á\ËÛl@3ø‘}ã‹NüÚ¶4Â«}Rg8¦PÈâIørn½ğÿ»ÜÑÛ™,æÈ©Ó½'¸³óoLÄş½İÃŞùPŒ¨åÀ0üóxrâo°´éµ7Ã/aæÏL;±õ‹"Y:S«Ñ¾ÔJ^´œØào¥ü]'?K\%•$ï›Q    Nà  ‚L8@‰)M#¸7ÉõÜ"^g?¬.W¬ß~Y¥ÌÓAÖ~¨ìÇ5¿ªhj‡şº¹˜
]¶xÅ›ûŠ‹Á4,q'“‰zrh±ıIÔTßÕÚşQÓÃêaãêÍ»z\X4sàsaÀµ÷\ò>ÿ¶*2Ï88+:¬‘Ô8×¯HÙêÃXlëTXCâ§xÄù©ÀBd Ná*r#š  æZq÷›+©Ü†Â«œ[s<{ÅˆX€äöJàabÙÉ\Eâ¡î¸±n1	Ğ¸CÀ|"è=¯/İ!¹E`“‚{ãë>¹Ï2hã×‘bª8,WdK}Ç·$°Š¶#·¸ÓÜB)³D“Ÿ8 ÂáeÈ•œUŒÌ}"úÎT1è¥¬’Âp›ã®^kilzç¸İg×ƒ°ŠÄ*‹“û·lÔªÙ§bğŠÖaîl´GW®&.|°Í‘i™s¢6H¸ÍvåŠ®ÙlUš³•½OZF¤1 ?"ãp=»ënÓ<{¬¹áFÄxu~•3eGğo­Öê±Õ^ú×=‡ƒi—\…LE¶c„‘†Ñ0iÄ-9V¸gf·8›©®+±–®‘–V¼w¯´®¹vÏf½ùlåšÌ2FòEÄÌæç±®qâOnX~Ïr…îåxì¾è‹Æa‚fİ^Ë6EÎ³OíÒ4µöQˆ6Ş¹ÉÓ<¼õ}d¤aë.Ù¬ñÏy-ÃÂÃæ*â¬Ô#TÌæãÃnióšõoFT²ÿn?·*Ù.sÂ„E¦˜~CŸÛ›˜yä° 6qXéÇıíÇÕycYÊ+ŞgT²ó¬ºŠW…sßg"Ê‹K$Yxy]¤.',öå‡¼Øà¯—ÉèÜÍ‘aĞìì2Aír\‡åê©,bÃÎ}Å”¶JãZâön-ácw’°şİá$®&g5Àä0"Måô	î p7låí×<-‘„X7ºy¾ô¥ÛX'ªo
¤7YÆ@,%Š&À’]=’K‚CG3T!  –  Nâ  ÀAø Nâ+r#¤  Ù{3eu;l,Ç3Ç¸ŞWuªÃ8}„®P8…›6‘¶ÇS6j64r^ÄKÇ6+•m¨E`­°QÊpUë\Ãí\xEÅTè€¼fIÊì‰a(XE[ÛÙ¶=^â*Y\6îDİˆ{†ã3Åõ¬fâdC e2Š•·;&Âpœ‹=on7Ò÷Öià¸Ë9õ›‘n İ³+¡–Zëœ×vR‘·€¨ø¼F÷JäODX¯dt†`\ğï>vëÜ×
19Ç¹Õ-ÅÕ87ÖŠY(¯zD€óg ófë„JC¡ZD(Áª7^.J¥‡–®‚y¤Éúä]®o"{wÜâÏ=ydí’×ÖÔõqûVõÛ–íÓ³İNÙ÷zã1Ò‹ÆalgY§¼ÜxlË±2,Î˜œÁví×œ—I¬6¶X·-€c5%WuA‡p{ÑÊÅRó«ÛíÊ¯H5v6@ÜËŞEÌtËı¹UÕX²rèÖZeëòCc{Ë* ÆZ¸G¶Ë,¹Ìt¡Å¦»ÁfÈß\íåg øódƒ7’%	ŒÅÆ¿'KS\b+\S°XÙn»•åÙ,z÷ÈÅ—¶0,ïedì\í×<-‘ »g#*¡îvµÁ0´ÔN¸,f©fÀ%ÖÄ,tC´àÀA‚ Nã,r#® ÙPVÍ<Ø eU‰Ãî‘ç©i2Ûg}(Xlhæld7têáÁJòóY–q¥uumbÎB,~çöåp°9]à–QQ¹p9î~âÊ+˜çn3”X7ôílQ}ĞKË€XEk¸œÌ=Àr&¥wv.3=¹aûÕ±İ‡³›¤Ëg1]ÎÌo/»fjaU¹×KNLÏŒ3xén•Tl7VÓƒÎÜ3O|Û+(lpÙ³Œ¼¾±ü½f‘åÈÉ´ŞDöïÉİÎ,ó¾+ü!v 6v¾õÜ=ºvvän›^ÆÀ½ï'$U3Ç½qy¸ğ˜89œ×Çx,,úÈ’>,»²öåW„ø‘eñÑ!
¿¨YYy2ãü¢¹fÉeÉ¥’âZÁÒê´ğ/Àî³Ğ,Éá²Ğ;
Å—p«Šf[‘!‘äœ¬SŞX^PÙŞ²²$Şß]Ò9Ï*µ€Z–EÎ6Oo §¼ÙÄ±åÒdò]c²HaÁ<í‡  Œ   O*  ;…ò7År*F¤T¡~K'ÊÿúéDfhMÁIÄÙ¡³Dsíæˆ¹i$yÇÈWE¸Ùş÷/Lº…ƒó\¡ ¿ªàÜÛÔWşN{2zÒ7†k-˜¼ÙSóŒR\ôê
¶ƒ†ç0ºº<ñf,"“ŞHr?³Tç[- ü»¹İ…dò3EòsÅ2*Ê&¦¡ô7õ	Âh8¡˜¥)HÀÎµİ\âCCìÏ¤¨I%¡ß=b±ùĞZÄj@.¼±ÒalIŸşdÛâ%>EAJh`šfÿoÙ†AŞŠ¿ÿ˜fS0ŒáöESåÄyŞ.˜†@2¥±àÀÿ·o•d­Úò3Åò7Åv*Fü5˜Ÿı'´ñÄæ-XŒü p/ä{üÆ‰[:¦1pƒ^\5aƒ„[ğ°Î¨Æˆ¨¿ZĞ¯_ƒéÖY±Ÿ€…¾´öıVÓ xŠQğçMŒ¥û=‚XRÛ34G­¸^¦£Ö%sãëK¡LZXã¬/È¥»©ò?Åò7Å²*,Ê ÷R0ÙréCËn
í_²*EJ!ø¨†#Ö¥Ô±è Äïo6Û_W¨héj5}½ÈÃºY™|ş)
s ra¯wë´kÉŸ¤å”³>"[S>?¡yÑ3L0V:J»y…éT@×ÙÃïo”j—èô
á1z3…ò7År*Ë%„5±´Â´”ßîğ.¨°ÔWÄwø‘% Ë—vß §hC½¨b×“=Ë’k”2¦'w¥áÛßöX~^¢0*²Tô²vJƒâGNöÙ0Uaá·¦õ}ºS¢óÖë†•ŞCK‰¶›Ê¹ªõ—ìÆ2Â  ú  O€  HÃ@ -N#à 	ê„¿äg;à0ùwÛu§-4rÉ’Ùò‡;§¡‚Í±. ‹<u÷ğC“^û0‰hg[(k¤‰Ï‘×“Ç§L¸’{²d™ÎÀ8Û¹€ šP0`û×uK‘EÓü;+Õ¾wèëÙtC]†Ó]3Ÿ
ËhníØ¹àJs›QêóìÂ×F­¿3Ë”«²Aß·ÜAò@WÏR²kQ–½Ãõ
o6É›Gc¿‘“@‰Ô—ÙVç†`Y9^=xÒ4á²ó+={†r»ğª÷™ÖéÒÅ ¢Ìƒ¸Ÿµ¬äœJXÈe1wÖ	?œ?[­º™Ó*•eæ„á-×æÊfªÌŸ;-ª°%[~%-WjİÂ”PÆÓ¬ªôÁ2ôõr½`¶[C{O;aß~£É£’†ºS"˜âD«ÉfvúlÌWAz÷n«?ÕI½½ÆÜ:Å‘õÆ¦pgÆÏïÀİ«CŸLËgõdQû"Èq??‚}#î×Áğ{ÅSæ¹²‘²£ìb¨]9ÿ íq$“@Hıø&|,¥ÜÅÎ¢F“£îD×JÙFs¾•znY)ãSDŠT¹”ŞÖKInOiDÓ;õìÛšI}÷D’ãdíèü¤üQ;5ÏXéç}æ\t÷,{¦¹	ºb‡×t0?Í–G^QûXIÔÚA†Úm]>[šrô—$—ÃµÜ6UôñÅß¢`4·:~vY%¡Òš]±,éæc	¶öAh’ÒRP©ÏÂÎŸœíóğôøxz§²'T–ã,w–¹0všå¼¤ßÖ)scù°3Ô!ØŠÀĞû–-LÔŒ1%óï×®Â]‚I¥ÈL0'y`fìÓåM€0¸lšêÒmhëLµÖ}há uš½Ó?Š&CÕ~bÎl!ãåğìô({ÜeÖ½ğq$Úİt+4±Ágv*htĞáÖ-/­¢õL)Rî†5»?×¸7i¿A6M’Ó)ÌéÑú1ßš‚Í/öyYb8†»åŠ9íøSMåÉqYŞ÷WC [¸á£‡}œPuJS¤RW›fUŸM·9úÄ/¬ó8ûËL’Kç±„¾¬ÎYwlnÿŒ')QP=ÏšŞ§l\í2^Éñ²éóú3®,#.òİ’¹¶èr%ÖUA³2vŞ¹âóB‹ìĞ M¡³s2™Qpùús÷ùîgJ#íîÛbòòân³¢ìá$mÏîÄ2úşˆ™M$ıe‡m+ƒj&„é~¸g‘…nÒKYÍıNKhíUà9ÖrÎá‘eåí{_÷u]yI’ÏÑÒI   ø  O€  ‚HÃCç-N#à+(ËCOã÷‰KÓú»†K3ÉÚºU¸Œ	êZ'Ÿ^²e
#ôwcİ"z†ŒÂL«J]XI$óLƒ­*¨š%mCµv”‹w‘”Zv“ÒwWÙ¼š2å%Ãyi¯ËºêèŠ[–; h¸a3}Ö'Í40Ñ&“KzÕX6_ÖpÇ®EÚjüQq¼R›b¾ÄDÓn&²…øÛÜ…Ñ34¹|˜×dõ9àwH@—i°5¥‰£½65õ’ììtAxæ¶é˜«†-ÛMfÍÚÎ÷[ÃœùÕp&»š§88wúİU	¾¨Ö·õ_U˜–boáì—İ}…RŒMÍµşÙ|;0B™ØEïséÉ¹ÿ|C‡=Ï A“ğa–"&¼`RÇéy·LÎ}H™ô©Ì;êáÔ’ú-¡÷å®NÉ/›Qº2Ü»ÒxÑ>‡N[lF[Ôû¡%…t÷1Ï«4v›ãÿÿÃffòO4(Ê¯y;&Êš`n“4Ö^çì!ÁÃå*ª~tÊ> ƒ
’j²|¬$)}2vsŞ	:”¿NÆ°’I'îW
é÷Ñõ2“‹	ùô™&´çSNYIÀ÷dÿË¾·”\°\¬ªY¥úwŠŒÖÓÅhÎÔÖá]]óˆÄ‹E°:aÙB¡çÍ¼ÓæüG÷bH¨·õ‡p^IúÕºiy>à©{ÔÀÃ¡)"Aôù¦sÜÁƒİä€Ö¥öÉy×Ÿº9³CdäŸx83úxÒóÍ¤ºñ7i£…^ç<mÌ	Ôß­s6C »§2ÿ³<ua¡$%f­ÄÙS1µ÷ç³/ã›v˜Ë²÷|ˆnİ¹BåK§ROÑŞ—>0ò~™ù„Ÿ¬h†Ÿ'ªŒoW.{Üßµç\f<šoÉKŸöÖş›€”í)×q:¤ü%ƒŸK™xdškØU8ô™}ÏšC^éögŸ|ïÍj-%\V¤¦-ËÒr»m²s‰ ÷lß°î‹ &QTÈ£õE°TocõÑ‡¿ZÖisäÿ‡HùüMú£®VE"áòü[‹.ú¤ÉC—Şãë×:FM ÒÁ’>¶e–IÏ6‰—5'î¡R‹İt£ôı™cÏ ì¢éÚÚ‰—5ä·i¼Š…Zù¼Ø…ˆ
8Fó­Ó´3=ƒˆ{ê¶¦ê·ôTÙ;ÂËİôcÜ|¾G×dU ¢|% }jæâ‡‡JRÎ€æ‚¨ŸœÕ@¹îÁ”V^–h šiÕp÷jMoÀJPMá¿%é O·ƒ’f3Tù§¿»¾F¿{§*f“)wÈîø½ğ’oa“~=#á­åøıÂ6˜êh  Ô  O€  ƒHÃ@÷-N#à6©g]&af[xËĞù4<Iûq3¨ÍYt×4oybêï"j)3ÙÏ™)¥áÙÉ‡‘ƒÀ‹¶2ÀMf¹ÎŞI¦°$!³®©‚¥­úó7ˆ>$:PÁdíé”g+6A¶Ÿ×i>Iñcr1anñQ  0˜©‚õÓ° y'¡³íîh¤¿jaÏq|™.½oó"©d
ëXÌ2dîƒ%ºõ·Y;…FfY7N{¡ñ1Ÿ›OÛ æÚíõ}¨õ–“U­kW£ÓîĞ _5š©¶Í—´?êbQË¾¬,ÜQú]«fN!”u#©.¬fk#:·»ÉÀ@[ O.r#Â YpŒ*´c&±2l¬)à-ÂM¸&ÀFñ.’@F\œ	 M”„ ÊªÙ§>rÂ©™%VfdŞå#¸ölƒŞ¬Ù
"H’ÈN’Ì¸$’XñÕIÀA° O‚/r#Ì ²¬)fÀlõ€‹a¼Ø_bœè¹ËHBZ{˜¹qª…Æk¢7'tÂ*†P›isi’<YçJx²:srGe/Ë—GLÉ*²«+jø¶©•géq©É»2ìä÷H&Z[ Dî…ä\òå®höèÅ•ÑË“"ÎÎ58Ÿ¸•ªv:Áéœ³>»¬ËßíÄY‡+«aUlîâ’Y³£]RY3!÷‹*µŸsá&Sçšr/0DÏK],CŸ9:q[Û#·qE×‘a®ën6h‚ÈºÓÎsù„yÍÄOd§Qeşˆ¶¹{ŒUĞ9l6ç›4÷–îlßÌS5)2ø,b©‘8×Er$ÙnØëMŸxáàhè”½†Ì¥–€„aé$Í"…Î]4ÕÈÏœmk'ÅNİ¹¹uBLËïíÉ5Ü“cÚş-íÅğX|Bÿn€®ç&%ÂÏ@™µUåÆ£+X‡¸[*ë‘;g*©âã3˜m$‘­Zç¼‚G-¦S7Á»!KaÀ	‚0½›X”„Ëa%øÎ‡¤Ö*fäâÀ:À`.&á<&C§€9‚WÀ@§ Oƒ0r#Ö ,ØpYÖÉà‹5rH{0ˆ¼‚È’”†&:3aÌf‘d^óŞµË@{jK­c0Ä‘Àdcpf7d	;xx·³d«fzD¨á‘üSÔn=†‚ÈÂÎòNwğÎ‘›,>äIÉ É²Ìt°³sÌ°Š¨·.Ùè‡±›‘qs6"»–ÁiÂ*?-«ï.a\ÉfÜõÌØÉ–òd/%„V  Œ   O  ?Åò7År*Ê&TÛòÔÂ	Â68îtŞ÷-ZÛäÎ{ÁÒ^zÁı(Ç?b"Bv\= †!b¡âú?ÑF{ ‹Á®vûH!"á4O·‡º³jÅs˜vÄhÒK§Ñ÷ĞÂKwQnÚzâdühÀK,Ö>¼ÜÄŸuò;…ò7År*	(»Ar4İ)*8*á'/¡dïàº‡FüùÇAY)b¯š° ™uq¦ló	¿¡À»aC¢HêŠ‡ÌßL,¾\ôã:\VŒƒªOÏyÍ<Ş:NlyÛT_Õ[²ŸÊ»öª5„)»N*oÛe9,?_aÇØ ™Ğ;…ò7Å2*.&£—Qx†ûêrFî·lX™thtû`û9ÙêŸº2F¹,µĞ®–Z%CÑäãœ8˜ú×n×Ø[‚l¡Ú_ÕªqÈ¨íFíâÓLhµ„9¨×[+F’.éç=Ê­ÕÛÓóír©¾Ò%Ûİ@Â¯¤r3Åò7Åò/Då‘´H’Ñ,úèó,Ec.x§È„QPµ}<-eñ¦±¿dÔx(ë¯¯T“^qã